<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MapleStory Mini - 메이플 미니게임</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: 'Segoe UI', sans-serif;
            color: white;
            overflow-x: hidden;
        }
        h1 {
            margin: 20px 0 10px;
            font-size: 28px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            background: linear-gradient(90deg, #ff9a56, #ffcd56);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        #game-container {
            position: relative;
            margin: 10px;
        }
        #gameCanvas {
            border: 3px solid #4a4a6a;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(100, 100, 255, 0.3);
            background: #000;
        }
        #ui-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
        }
        .stat-box {
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 15px;
            border-radius: 8px;
            border: 1px solid #4a4a6a;
        }
        .stat-label {
            font-size: 11px;
            color: #aaa;
        }
        .stat-value {
            font-size: 16px;
            font-weight: bold;
        }
        .level { color: #ffcd56; }
        .exp { color: #56ff56; }
        .hp { color: #ff5656; }
        .score { color: #56cdff; }

        #exp-bar-container {
            position: absolute;
            bottom: 50px;
            left: 10px;
            right: 10px;
            height: 20px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            border: 1px solid #4a4a6a;
            overflow: hidden;
        }
        #exp-bar {
            height: 100%;
            background: linear-gradient(90deg, #56ff56, #00ff88);
            width: 0%;
            transition: width 0.3s;
        }
        #exp-text {
            position: absolute;
            width: 100%;
            text-align: center;
            line-height: 20px;
            font-size: 12px;
            text-shadow: 1px 1px 2px black;
        }

        #hp-bar-container {
            position: absolute;
            bottom: 75px;
            left: 10px;
            right: 10px;
            height: 16px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 8px;
            border: 1px solid #4a4a6a;
            overflow: hidden;
        }
        #hp-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff5656, #ff8888);
            width: 100%;
            transition: width 0.3s;
        }
        #hp-text {
            position: absolute;
            width: 100%;
            text-align: center;
            line-height: 16px;
            font-size: 11px;
            text-shadow: 1px 1px 2px black;
        }

        #controls {
            margin: 15px;
            text-align: center;
            color: #aaa;
            font-size: 13px;
        }
        .key {
            display: inline-block;
            background: #333;
            padding: 3px 8px;
            border-radius: 4px;
            margin: 0 3px;
            border: 1px solid #555;
        }

        #start-screen, #gameover-screen, #levelup-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 10px;
        }
        #start-screen h2, #gameover-screen h2, #levelup-screen h2 {
            font-size: 36px;
            margin-bottom: 20px;
            background: linear-gradient(90deg, #ff9a56, #ffcd56);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        #levelup-screen h2 {
            background: linear-gradient(90deg, #56ff56, #00ffaa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .btn {
            background: linear-gradient(135deg, #ff9a56, #ff6b35);
            border: none;
            padding: 15px 40px;
            font-size: 18px;
            color: white;
            border-radius: 30px;
            cursor: pointer;
            margin: 10px;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 154, 86, 0.5);
        }

        #mob-preview {
            display: flex;
            gap: 20px;
            margin: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .mob-card {
            background: rgba(50, 50, 80, 0.8);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid #4a4a6a;
        }
        .mob-card img {
            width: 60px;
            height: 60px;
            object-fit: contain;
            image-rendering: pixelated;
        }
        .mob-name {
            font-size: 12px;
            margin-top: 5px;
            color: #ffcd56;
        }

        #damage-numbers {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            overflow: hidden;
        }
        .damage-number {
            position: absolute;
            font-weight: bold;
            font-size: 20px;
            text-shadow: 2px 2px 0 black, -1px -1px 0 black;
            animation: floatUp 1s ease-out forwards;
            pointer-events: none;
        }
        .damage-number.player { color: #ff5555; }
        .damage-number.mob { color: #ffff55; }
        .damage-number.crit { color: #ff00ff; font-size: 28px; }
        .damage-number.exp { color: #55ff55; font-size: 16px; }

        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-60px); }
        }

        #skill-bar {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
        }
        .skill-slot {
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #4a4a6a;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            position: relative;
        }
        .skill-slot .key-hint {
            position: absolute;
            top: -15px;
            font-size: 10px;
            color: #aaa;
        }
        .skill-slot.active {
            border-color: #ffcd56;
            box-shadow: 0 0 10px rgba(255, 205, 86, 0.5);
        }
        .skill-slot .cooldown {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.7);
            color: #ff5555;
            font-size: 10px;
            text-align: center;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
        }
    </style>
</head>
<body>
    <h1>MapleStory Mini</h1>

    <div id="game-container">
        <canvas id="gameCanvas" width="800" height="500"></canvas>

        <div id="ui-overlay">
            <div class="stat-box">
                <div class="stat-label">LEVEL</div>
                <div class="stat-value level" id="level-display">1</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">SCORE</div>
                <div class="stat-value score" id="score-display">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">KILLS</div>
                <div class="stat-value" id="kills-display">0</div>
            </div>
        </div>

        <div id="hp-bar-container">
            <div id="hp-bar"></div>
            <div id="hp-text">100 / 100</div>
        </div>

        <div id="exp-bar-container">
            <div id="exp-bar"></div>
            <div id="exp-text">0 / 100 EXP</div>
        </div>

        <div id="skill-bar">
            <div class="skill-slot" id="skill-attack">
                <span class="key-hint">Z</span>
                <span style="font-size:18px">&#9876;</span>
            </div>
            <div class="skill-slot" id="skill-special">
                <span class="key-hint">X</span>
                <span style="font-size:18px">&#10022;</span>
            </div>
            <div class="skill-slot" id="skill-heal">
                <span class="key-hint">C</span>
                <span style="font-size:18px">&#9829;</span>
            </div>
        </div>

        <div id="damage-numbers"></div>

        <div id="start-screen">
            <h2>MapleStory Mini</h2>
            <div id="mob-preview"></div>
            <p style="margin: 10px; color: #aaa;">Real MapleStory sprites mini game</p>
            <button class="btn" onclick="startGame()">Start Game</button>
        </div>

        <div id="gameover-screen" style="display: none;">
            <h2>Game Over</h2>
            <p style="font-size: 24px; margin: 10px;">Level: <span id="final-level">1</span></p>
            <p style="font-size: 20px; margin: 10px;">Score: <span id="final-score">0</span></p>
            <p style="font-size: 18px; margin: 10px; color: #aaa;">Kills: <span id="final-kills">0</span></p>
            <button class="btn" onclick="startGame()">Restart</button>
        </div>

        <div id="levelup-screen" style="display: none;">
            <h2>LEVEL UP!</h2>
            <p style="font-size: 28px; margin: 10px;">Level <span id="new-level">2</span></p>
            <p style="color: #56ff56; margin: 10px;">HP Restored! ATK increased!</p>
        </div>

        <div id="loading">Loading...</div>
    </div>

    <div id="controls">
        <span class="key">Arrow</span> Move &nbsp;
        <span class="key">Up</span> Jump &nbsp;
        <span class="key">Z</span> Attack &nbsp;
        <span class="key">X</span> Skill &nbsp;
        <span class="key">C</span> Heal
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game state
        let gameRunning = false;
        let player, mobs, platforms, effects;
        let keys = {};
        let sprites = { mobs: {}, character: {} };
        let mobData = {};
        let lastTime = 0;
        let spawnTimer = 0;

        // Mob configurations with actual data
        const MOB_TYPES = {
            '5120504': { name: 'Wood Doll', color: '#8B4513', scale: 1.0 },
            '5120503': { name: 'Blue Doll', color: '#4169E1', scale: 1.0 },
            '9300027': { name: 'Slime', color: '#32CD32', scale: 0.8 },
            '1541175': { name: 'Orange Mushroom', color: '#FFA500', scale: 0.9 },
            '9001007': { name: 'Snail', color: '#DDA0DD', scale: 0.85 },
            '7130602': { name: 'Ribbon Pig', color: '#FFB6C1', scale: 1.1 }
        };

        // Load sprites
        async function loadSprites() {
            const basePath = 'sprites/mobs/';

            for (const mobId of Object.keys(MOB_TYPES)) {
                sprites.mobs[mobId] = { stand: [], move: [], hit: [], die: [] };

                // Load JSON data
                try {
                    const response = await fetch(`${basePath}${mobId}.json`);
                    if (response.ok) {
                        mobData[mobId] = await response.json();
                    }
                } catch (e) {
                    console.log(`No JSON for ${mobId}`);
                }

                // Load stand sprites
                for (let i = 0; i < 6; i++) {
                    const img = new Image();
                    img.src = `${basePath}${mobId}/stand_${i}.png`;
                    await new Promise(resolve => {
                        img.onload = () => {
                            sprites.mobs[mobId].stand.push(img);
                            resolve();
                        };
                        img.onerror = resolve;
                    });
                }

                // Load move sprites
                for (let i = 0; i < 7; i++) {
                    const img = new Image();
                    img.src = `${basePath}${mobId}/move_${i}.png`;
                    await new Promise(resolve => {
                        img.onload = () => {
                            sprites.mobs[mobId].move.push(img);
                            resolve();
                        };
                        img.onerror = resolve;
                    });
                }

                // Load hit sprite
                const hitImg = new Image();
                hitImg.src = `${basePath}${mobId}/hit1_0.png`;
                await new Promise(resolve => {
                    hitImg.onload = () => {
                        sprites.mobs[mobId].hit.push(hitImg);
                        resolve();
                    };
                    hitImg.onerror = resolve;
                });

                // Load die sprites
                for (let i = 0; i < 6; i++) {
                    const img = new Image();
                    img.src = `${basePath}${mobId}/die1_${i}.png`;
                    await new Promise(resolve => {
                        img.onload = () => {
                            sprites.mobs[mobId].die.push(img);
                            resolve();
                        };
                        img.onerror = resolve;
                    });
                }
            }

            // Show mob preview
            showMobPreview();
            document.getElementById('loading').style.display = 'none';
        }

        function showMobPreview() {
            const preview = document.getElementById('mob-preview');
            for (const [mobId, config] of Object.entries(MOB_TYPES)) {
                if (sprites.mobs[mobId]?.stand[0]) {
                    const card = document.createElement('div');
                    card.className = 'mob-card';
                    card.innerHTML = `
                        <img src="${sprites.mobs[mobId].stand[0].src}" alt="${config.name}">
                        <div class="mob-name">${config.name}</div>
                    `;
                    preview.appendChild(card);
                }
            }
        }

        // Player class
        class Player {
            constructor() {
                this.x = 100;
                this.y = 350;
                this.width = 40;
                this.height = 60;
                this.vx = 0;
                this.vy = 0;
                this.speed = 5;
                this.jumpPower = -15;
                this.onGround = false;
                this.facing = 1; // 1 = right, -1 = left
                this.level = 1;
                this.exp = 0;
                this.expToLevel = 100;
                this.maxHp = 100;
                this.hp = 100;
                this.attack = 20;
                this.score = 0;
                this.kills = 0;
                this.attacking = false;
                this.attackFrame = 0;
                this.attackCooldown = 0;
                this.skillCooldown = 0;
                this.healCooldown = 0;
                this.invincible = 0;
                this.walkFrame = 0;
                this.walkTimer = 0;
            }

            update(dt) {
                // Movement
                if (keys['ArrowLeft'] || keys['arrowleft']) {
                    this.vx = -this.speed;
                    this.facing = -1;
                } else if (keys['ArrowRight'] || keys['arrowright']) {
                    this.vx = this.speed;
                    this.facing = 1;
                } else {
                    this.vx = 0;
                }

                // Jump
                if ((keys['ArrowUp'] || keys['arrowup']) && this.onGround) {
                    this.vy = this.jumpPower;
                    this.onGround = false;
                }

                // Attack
                if (keys['z'] && this.attackCooldown <= 0) {
                    this.startAttack();
                }

                // Special skill
                if (keys['x'] && this.skillCooldown <= 0) {
                    this.useSkill();
                }

                // Heal
                if (keys['c'] && this.healCooldown <= 0) {
                    this.heal();
                }

                // Gravity
                this.vy += 0.8;

                // Apply velocity
                this.x += this.vx;
                this.y += this.vy;

                // Platform collision
                this.onGround = false;
                for (const plat of platforms) {
                    if (this.vy > 0 &&
                        this.x + this.width > plat.x &&
                        this.x < plat.x + plat.width &&
                        this.y + this.height > plat.y &&
                        this.y + this.height < plat.y + 20) {
                        this.y = plat.y - this.height;
                        this.vy = 0;
                        this.onGround = true;
                    }
                }

                // Boundaries
                if (this.x < 0) this.x = 0;
                if (this.x > canvas.width - this.width) this.x = canvas.width - this.width;
                if (this.y > canvas.height - this.height) {
                    this.y = canvas.height - this.height;
                    this.vy = 0;
                    this.onGround = true;
                }

                // Cooldowns
                if (this.attackCooldown > 0) this.attackCooldown -= dt;
                if (this.skillCooldown > 0) this.skillCooldown -= dt;
                if (this.healCooldown > 0) this.healCooldown -= dt;
                if (this.invincible > 0) this.invincible -= dt;

                // Attack animation
                if (this.attacking) {
                    this.attackFrame += dt * 10;
                    if (this.attackFrame >= 3) {
                        this.attacking = false;
                        this.attackFrame = 0;
                    }
                }

                // Walk animation
                if (this.vx !== 0) {
                    this.walkTimer += dt;
                    if (this.walkTimer > 0.1) {
                        this.walkFrame = (this.walkFrame + 1) % 4;
                        this.walkTimer = 0;
                    }
                }

                // Update UI
                this.updateUI();
            }

            startAttack() {
                this.attacking = true;
                this.attackFrame = 0;
                this.attackCooldown = 0.3;

                const attackRange = {
                    x: this.facing > 0 ? this.x + this.width : this.x - 80,
                    y: this.y,
                    width: 80,
                    height: this.height
                };

                for (const mob of mobs) {
                    if (mob.state !== 'dead' && this.checkCollision(attackRange, mob)) {
                        const damage = this.attack + Math.floor(Math.random() * 10) + (this.level * 2);
                        const crit = Math.random() < 0.1;
                        mob.takeDamage(crit ? damage * 2 : damage, crit);
                    }
                }

                // Attack effect
                effects.push({
                    type: 'slash',
                    x: attackRange.x,
                    y: this.y + 20,
                    width: 80,
                    facing: this.facing,
                    life: 0.2
                });
            }

            useSkill() {
                this.skillCooldown = 3;

                // AoE attack
                for (const mob of mobs) {
                    if (mob.state !== 'dead') {
                        const dist = Math.abs(mob.x - this.x);
                        if (dist < 200) {
                            const damage = this.attack * 2 + (this.level * 5);
                            mob.takeDamage(damage, true);
                        }
                    }
                }

                effects.push({
                    type: 'skill',
                    x: this.x + this.width / 2,
                    y: this.y + this.height / 2,
                    radius: 0,
                    maxRadius: 200,
                    life: 0.5
                });
            }

            heal() {
                this.healCooldown = 5;
                const healAmount = Math.floor(this.maxHp * 0.3);
                this.hp = Math.min(this.hp + healAmount, this.maxHp);
                showDamageNumber(this.x + this.width/2, this.y, '+' + healAmount, 'exp');

                effects.push({
                    type: 'heal',
                    x: this.x + this.width / 2,
                    y: this.y + this.height,
                    life: 0.8
                });
            }

            takeDamage(amount) {
                if (this.invincible > 0) return;
                this.hp -= amount;
                this.invincible = 1;
                showDamageNumber(this.x + this.width/2, this.y, amount, 'player');

                if (this.hp <= 0) {
                    gameOver();
                }
            }

            gainExp(amount) {
                this.exp += amount;
                showDamageNumber(this.x + this.width/2, this.y - 20, '+' + amount + ' EXP', 'exp');

                while (this.exp >= this.expToLevel) {
                    this.levelUp();
                }
            }

            levelUp() {
                this.exp -= this.expToLevel;
                this.level++;
                this.expToLevel = Math.floor(this.expToLevel * 1.5);
                this.maxHp += 20;
                this.hp = this.maxHp;
                this.attack += 5;

                // Show level up screen
                document.getElementById('new-level').textContent = this.level;
                document.getElementById('levelup-screen').style.display = 'flex';
                setTimeout(() => {
                    document.getElementById('levelup-screen').style.display = 'none';
                }, 1500);
            }

            checkCollision(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }

            updateUI() {
                document.getElementById('level-display').textContent = this.level;
                document.getElementById('score-display').textContent = this.score;
                document.getElementById('kills-display').textContent = this.kills;
                document.getElementById('hp-bar').style.width = (this.hp / this.maxHp * 100) + '%';
                document.getElementById('hp-text').textContent = `${Math.max(0, Math.floor(this.hp))} / ${this.maxHp}`;
                document.getElementById('exp-bar').style.width = (this.exp / this.expToLevel * 100) + '%';
                document.getElementById('exp-text').textContent = `${this.exp} / ${this.expToLevel} EXP`;

                // Skill cooldowns
                document.getElementById('skill-attack').querySelector('.cooldown')?.remove();
                document.getElementById('skill-special').querySelector('.cooldown')?.remove();
                document.getElementById('skill-heal').querySelector('.cooldown')?.remove();

                if (this.skillCooldown > 0) {
                    const cd = document.createElement('div');
                    cd.className = 'cooldown';
                    cd.textContent = Math.ceil(this.skillCooldown);
                    document.getElementById('skill-special').appendChild(cd);
                }
                if (this.healCooldown > 0) {
                    const cd = document.createElement('div');
                    cd.className = 'cooldown';
                    cd.textContent = Math.ceil(this.healCooldown);
                    document.getElementById('skill-heal').appendChild(cd);
                }
            }

            draw() {
                ctx.save();

                // Flash when invincible
                if (this.invincible > 0 && Math.floor(this.invincible * 10) % 2 === 0) {
                    ctx.globalAlpha = 0.5;
                }

                // Draw player
                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                ctx.scale(this.facing, 1);

                // Body
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(-15, -25, 30, 50);

                // Head
                ctx.fillStyle = '#FFDAB9';
                ctx.beginPath();
                ctx.arc(0, -30, 15, 0, Math.PI * 2);
                ctx.fill();

                // Hair
                ctx.fillStyle = '#8B4513';
                ctx.beginPath();
                ctx.arc(0, -35, 12, Math.PI, 0);
                ctx.fill();

                // Eyes
                ctx.fillStyle = '#000';
                ctx.fillRect(-5, -32, 3, 3);
                ctx.fillRect(2, -32, 3, 3);

                // Attack animation
                if (this.attacking) {
                    ctx.strokeStyle = '#FFF';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(15, -10);
                    ctx.lineTo(40 + this.attackFrame * 10, -10 + this.attackFrame * 5);
                    ctx.stroke();
                }

                ctx.restore();
            }
        }

        // Mob class
        class Mob {
            constructor(type, x, y) {
                this.type = type;
                this.x = x;
                this.y = y;
                this.width = 60;
                this.height = 60;
                this.vx = 0;
                this.vy = 0;
                this.facing = Math.random() < 0.5 ? -1 : 1;
                this.state = 'stand'; // stand, move, hit, dead
                this.frame = 0;
                this.frameTimer = 0;
                this.hitTimer = 0;
                this.deathTimer = 0;
                this.moveTimer = 0;
                this.moveDirection = 0;

                // Get stats from JSON or use defaults
                const data = mobData[type];
                if (data?.info) {
                    this.level = data.info.level || 10;
                    this.maxHp = Math.min(data.info.maxHP, 500 + player.level * 50);
                    this.hp = this.maxHp;
                    this.attack = Math.min(data.info.PADamage, 10 + player.level * 2);
                    this.exp = data.info.exp || 20;
                    this.speed = Math.abs(data.info.speed) / 50 || 1;
                } else {
                    this.level = 5 + Math.floor(player.level * 0.8);
                    this.maxHp = 50 + player.level * 20;
                    this.hp = this.maxHp;
                    this.attack = 5 + player.level;
                    this.exp = 10 + player.level * 5;
                    this.speed = 1 + Math.random();
                }

                // Adjust for player level
                const scale = MOB_TYPES[type]?.scale || 1;
                this.width *= scale;
                this.height *= scale;
            }

            update(dt) {
                if (this.state === 'dead') {
                    this.deathTimer += dt;
                    this.frame = Math.min(Math.floor(this.deathTimer * 8), 5);
                    if (this.deathTimer > 0.8) {
                        return true; // Remove mob
                    }
                    return false;
                }

                if (this.state === 'hit') {
                    this.hitTimer -= dt;
                    if (this.hitTimer <= 0) {
                        this.state = 'stand';
                    }
                    return false;
                }

                // AI
                this.moveTimer -= dt;
                if (this.moveTimer <= 0) {
                    this.moveTimer = 1 + Math.random() * 2;
                    const dx = player.x - this.x;
                    if (Math.abs(dx) < 300) {
                        // Chase player
                        this.moveDirection = dx > 0 ? 1 : -1;
                        this.state = 'move';
                    } else if (Math.random() < 0.5) {
                        this.moveDirection = Math.random() < 0.5 ? -1 : 1;
                        this.state = 'move';
                    } else {
                        this.moveDirection = 0;
                        this.state = 'stand';
                    }
                }

                // Movement
                if (this.state === 'move') {
                    this.vx = this.moveDirection * this.speed;
                    this.facing = this.moveDirection;
                } else {
                    this.vx = 0;
                }

                // Gravity
                this.vy += 0.5;

                // Apply
                this.x += this.vx;
                this.y += this.vy;

                // Platform collision
                for (const plat of platforms) {
                    if (this.vy > 0 &&
                        this.x + this.width > plat.x &&
                        this.x < plat.x + plat.width &&
                        this.y + this.height > plat.y &&
                        this.y + this.height < plat.y + 20) {
                        this.y = plat.y - this.height;
                        this.vy = 0;
                    }
                }

                // Boundaries
                if (this.x < 0) { this.x = 0; this.moveDirection *= -1; }
                if (this.x > canvas.width - this.width) {
                    this.x = canvas.width - this.width;
                    this.moveDirection *= -1;
                }
                if (this.y > canvas.height - this.height) {
                    this.y = canvas.height - this.height;
                    this.vy = 0;
                }

                // Animation
                this.frameTimer += dt;
                if (this.frameTimer > 0.1) {
                    this.frameTimer = 0;
                    const spriteSet = sprites.mobs[this.type]?.[this.state] || [];
                    this.frame = (this.frame + 1) % Math.max(1, spriteSet.length);
                }

                // Attack player
                if (this.checkCollision(player)) {
                    player.takeDamage(this.attack);
                }

                return false;
            }

            takeDamage(amount, crit = false) {
                this.hp -= amount;
                this.state = 'hit';
                this.hitTimer = 0.3;
                showDamageNumber(this.x + this.width/2, this.y, amount, crit ? 'crit' : 'mob');

                if (this.hp <= 0) {
                    this.die();
                }
            }

            die() {
                this.state = 'dead';
                this.deathTimer = 0;
                this.frame = 0;
                player.kills++;
                player.score += this.level * 10;
                player.gainExp(this.exp);
            }

            checkCollision(other) {
                return this.x < other.x + other.width &&
                       this.x + this.width > other.x &&
                       this.y < other.y + other.height &&
                       this.y + this.height > other.y;
            }

            draw() {
                const spriteSet = sprites.mobs[this.type];
                let currentSprites;

                if (this.state === 'dead') {
                    currentSprites = spriteSet?.die;
                } else if (this.state === 'hit') {
                    currentSprites = spriteSet?.hit;
                } else if (this.state === 'move') {
                    currentSprites = spriteSet?.move?.length > 0 ? spriteSet.move : spriteSet?.stand;
                } else {
                    currentSprites = spriteSet?.stand;
                }

                const sprite = currentSprites?.[this.frame % currentSprites?.length];

                ctx.save();
                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                ctx.scale(this.facing, 1);

                if (sprite) {
                    // Draw actual sprite
                    const scale = MOB_TYPES[this.type]?.scale || 1;
                    ctx.drawImage(sprite, -sprite.width * scale / 2, -sprite.height * scale / 2,
                                  sprite.width * scale, sprite.height * scale);
                } else {
                    // Fallback
                    ctx.fillStyle = MOB_TYPES[this.type]?.color || '#888';
                    ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
                }

                ctx.restore();

                // HP bar
                if (this.state !== 'dead') {
                    const hpPercent = this.hp / this.maxHp;
                    ctx.fillStyle = '#333';
                    ctx.fillRect(this.x, this.y - 10, this.width, 5);
                    ctx.fillStyle = hpPercent > 0.3 ? '#4f4' : '#f44';
                    ctx.fillRect(this.x, this.y - 10, this.width * hpPercent, 5);
                }
            }
        }

        // Show damage number
        function showDamageNumber(x, y, value, type) {
            const div = document.createElement('div');
            div.className = `damage-number ${type}`;
            div.textContent = value;
            div.style.left = x + 'px';
            div.style.top = y + 'px';
            document.getElementById('damage-numbers').appendChild(div);
            setTimeout(() => div.remove(), 1000);
        }

        // Spawn mobs
        function spawnMob() {
            const types = Object.keys(MOB_TYPES).filter(t => sprites.mobs[t]?.stand?.length > 0);
            if (types.length === 0) return;

            const type = types[Math.floor(Math.random() * types.length)];
            const side = Math.random() < 0.5 ? 0 : canvas.width - 60;
            const platY = platforms[Math.floor(Math.random() * platforms.length)];
            const y = platY ? platY.y - 60 : canvas.height - 80;

            mobs.push(new Mob(type, side, y));
        }

        // Draw platforms
        function drawPlatforms() {
            ctx.fillStyle = '#4a3728';
            for (const plat of platforms) {
                // Main platform
                ctx.fillRect(plat.x, plat.y, plat.width, plat.height);
                // Grass top
                ctx.fillStyle = '#228B22';
                ctx.fillRect(plat.x, plat.y, plat.width, 5);
                ctx.fillStyle = '#4a3728';
            }
        }

        // Draw effects
        function drawEffects(dt) {
            effects = effects.filter(e => {
                e.life -= dt;
                if (e.life <= 0) return false;

                ctx.save();
                ctx.globalAlpha = e.life * 2;

                if (e.type === 'slash') {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    const progress = 1 - e.life / 0.2;
                    ctx.moveTo(e.x, e.y);
                    ctx.lineTo(e.x + e.width * e.facing * progress, e.y + 20 * progress);
                    ctx.stroke();
                }

                if (e.type === 'skill') {
                    e.radius += (e.maxRadius - e.radius) * 0.2;
                    ctx.strokeStyle = '#ffcd56';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
                    ctx.stroke();
                }

                if (e.type === 'heal') {
                    ctx.fillStyle = '#56ff56';
                    for (let i = 0; i < 5; i++) {
                        const angle = (i / 5) * Math.PI * 2 + e.life * 5;
                        const dist = 20 + (1 - e.life) * 30;
                        ctx.beginPath();
                        ctx.arc(e.x + Math.cos(angle) * dist, e.y - (1 - e.life) * 50 + Math.sin(angle) * dist * 0.3,
                                3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                ctx.restore();
                return true;
            });
        }

        // Draw background
        function drawBackground() {
            // Sky gradient
            const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
            grad.addColorStop(0, '#1a1a2e');
            grad.addColorStop(0.5, '#16213e');
            grad.addColorStop(1, '#0f0f23');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Stars
            ctx.fillStyle = '#fff';
            for (let i = 0; i < 50; i++) {
                const x = (i * 37) % canvas.width;
                const y = (i * 23) % (canvas.height / 2);
                const size = (i % 3) + 1;
                ctx.globalAlpha = 0.3 + Math.sin(Date.now() / 1000 + i) * 0.2;
                ctx.fillRect(x, y, size, size);
            }
            ctx.globalAlpha = 1;
        }

        // Game loop
        function gameLoop(timestamp) {
            if (!gameRunning) return;

            const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
            lastTime = timestamp;

            // Update
            player.update(dt);
            mobs = mobs.filter(mob => !mob.update(dt));

            // Spawn mobs
            spawnTimer -= dt;
            if (spawnTimer <= 0 && mobs.length < 5 + player.level) {
                spawnMob();
                spawnTimer = Math.max(1, 3 - player.level * 0.2);
            }

            // Draw
            drawBackground();
            drawPlatforms();
            mobs.forEach(mob => mob.draw());
            player.draw();
            drawEffects(dt);

            requestAnimationFrame(gameLoop);
        }

        // Start game
        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('gameover-screen').style.display = 'none';

            player = new Player();
            mobs = [];
            effects = [];
            platforms = [
                { x: 0, y: canvas.height - 20, width: canvas.width, height: 20 },
                { x: 100, y: 380, width: 200, height: 15 },
                { x: 500, y: 380, width: 200, height: 15 },
                { x: 250, y: 280, width: 300, height: 15 },
                { x: 50, y: 180, width: 150, height: 15 },
                { x: 600, y: 180, width: 150, height: 15 }
            ];
            spawnTimer = 1;
            gameRunning = true;
            lastTime = performance.now();

            requestAnimationFrame(gameLoop);
        }

        // Game over
        function gameOver() {
            gameRunning = false;
            document.getElementById('final-level').textContent = player.level;
            document.getElementById('final-score').textContent = player.score;
            document.getElementById('final-kills').textContent = player.kills;
            document.getElementById('gameover-screen').style.display = 'flex';
        }

        // Input
        document.addEventListener('keydown', e => {
            keys[e.key.toLowerCase()] = true;
            keys[e.key] = true;
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', e => {
            keys[e.key.toLowerCase()] = false;
            keys[e.key] = false;
        });

        // Initialize
        loadSprites();
    </script>
</body>
</html>
