<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MapleStory - Authentic Mini Game</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }
        #game-container {
            position: relative;
            background: #000;
        }
        #gameCanvas {
            display: block;
            image-rendering: pixelated;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }
        .stat-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            color: #fff;
            font-size: 14px;
        }
        .bar-container {
            width: 200px;
            height: 16px;
            background: #333;
            border-radius: 3px;
            margin: 3px 0;
            position: relative;
            overflow: hidden;
        }
        .hp-bar { background: linear-gradient(90deg, #ff3333, #ff6666); height: 100%; transition: width 0.2s; }
        .mp-bar { background: linear-gradient(90deg, #3366ff, #6699ff); height: 100%; transition: width 0.2s; }
        .exp-bar { background: linear-gradient(90deg, #ffcc00, #ffff66); height: 100%; transition: width 0.2s; }
        .bar-text {
            position: absolute;
            width: 100%;
            text-align: center;
            line-height: 16px;
            font-size: 11px;
            color: #fff;
            text-shadow: 1px 1px 1px #000;
        }
        .score-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px 15px;
            border-radius: 5px;
            color: #ffcc00;
            font-size: 18px;
            text-shadow: 2px 2px 2px #000;
        }
        #loading-screen {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 20px;
        }
        .loading-bar {
            width: 300px;
            height: 20px;
            background: #333;
            border-radius: 10px;
            margin-top: 20px;
            overflow: hidden;
        }
        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #ff9900, #ffcc00);
            width: 0%;
            transition: width 0.3s;
        }
        #start-screen {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.8);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #fff;
        }
        #start-screen h1 {
            font-size: 48px;
            color: #ffcc00;
            text-shadow: 3px 3px 0 #ff6600, 5px 5px 10px rgba(0,0,0,0.5);
            margin-bottom: 30px;
        }
        .start-btn {
            background: linear-gradient(180deg, #ff9900, #ff6600);
            border: 3px solid #ffcc00;
            padding: 15px 50px;
            font-size: 24px;
            color: #fff;
            border-radius: 10px;
            cursor: pointer;
            text-shadow: 2px 2px 2px #000;
            transition: transform 0.2s;
        }
        .start-btn:hover {
            transform: scale(1.1);
        }
        #controls-hint {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 8px 15px;
            border-radius: 5px;
            color: #aaa;
            font-size: 12px;
        }
        .damage-popup {
            position: absolute;
            font-weight: bold;
            font-size: 24px;
            color: #ffff00;
            text-shadow: 2px 2px 0 #000, -1px -1px 0 #ff6600;
            animation: damageFloat 1s ease-out forwards;
            pointer-events: none;
        }
        .damage-popup.crit {
            font-size: 32px;
            color: #ff00ff;
        }
        .damage-popup.player {
            color: #ff3333;
        }
        .damage-popup.exp {
            color: #00ff00;
            font-size: 16px;
        }
        @keyframes damageFloat {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-50px); }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="ui-layer">
            <div class="stat-panel">
                <div>Lv. <span id="level">1</span> <span id="charName">Player</span></div>
                <div class="bar-container">
                    <div class="hp-bar" id="hp-bar" style="width: 100%"></div>
                    <div class="bar-text"><span id="hp-cur">100</span> / <span id="hp-max">100</span></div>
                </div>
                <div class="bar-container">
                    <div class="mp-bar" id="mp-bar" style="width: 100%"></div>
                    <div class="bar-text"><span id="mp-cur">50</span> / <span id="mp-max">50</span></div>
                </div>
                <div class="bar-container">
                    <div class="exp-bar" id="exp-bar" style="width: 0%"></div>
                    <div class="bar-text"><span id="exp-cur">0</span> / <span id="exp-max">100</span></div>
                </div>
            </div>
            <div class="score-panel">
                Score: <span id="score">0</span><br>
                <span style="font-size: 14px; color: #aaa;">Kills: <span id="kills">0</span></span>
            </div>
            <div id="controls-hint">
                Arrow Keys: Move | Z: Attack | X: Skill | C: Jump
            </div>
        </div>
        <div id="loading-screen">
            <div>Loading MapleStory...</div>
            <div class="loading-bar">
                <div class="loading-progress" id="loading-progress"></div>
            </div>
            <div id="loading-text" style="margin-top: 10px; font-size: 14px; color: #aaa;">Initializing...</div>
        </div>
        <div id="start-screen">
            <h1>MapleStory</h1>
            <button class="start-btn" onclick="startGame()">Start Game</button>
        </div>
    </div>

    <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Game dimensions
    const GAME_WIDTH = 900;
    const GAME_HEIGHT = 600;
    canvas.width = GAME_WIDTH;
    canvas.height = GAME_HEIGHT;

    // Game state
    let gameRunning = false;
    let lastTime = 0;
    let keys = {};

    // Assets
    const assets = {
        backgrounds: {},
        character: { sprites: {}, data: null },
        mobs: {},
        effects: {},
        skills: {}
    };

    // Map data
    let mapData = null;
    let footholds = [];

    // Camera
    const camera = { x: 0, y: 0 };

    // Player
    const player = {
        x: 0, y: -100,
        vx: 0, vy: 0,
        width: 40, height: 65,
        facing: 1,
        onGround: false,
        state: 'stand1',
        frame: 0,
        frameTimer: 0,
        level: 1,
        hp: 100, maxHp: 100,
        mp: 50, maxMp: 50,
        exp: 0, expToLevel: 100,
        attack: 30,
        score: 0,
        kills: 0,
        attacking: false,
        attackTimer: 0,
        skillCooldown: 0,
        invincible: 0
    };

    // Mobs
    let mobs = [];
    let mobSpawnTimer = 0;

    // Damage popups
    let damagePopups = [];

    // Effects
    let effects = [];

    // Mob types available
    const MOB_TYPES = ['5120504', '5120503', '9300027'];

    // Load image helper
    function loadImage(src) {
        return new Promise((resolve) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = () => resolve(null);
            img.src = src;
        });
    }

    // Load all assets
    async function loadAssets() {
        const loadingProgress = document.getElementById('loading-progress');
        const loadingText = document.getElementById('loading-text');
        let loaded = 0;
        const total = 100;

        const updateProgress = (text) => {
            loaded += 5;
            loadingProgress.style.width = Math.min(loaded, 100) + '%';
            loadingText.textContent = text;
        };

        // Load backgrounds
        updateProgress('Loading backgrounds...');
        for (let i = 0; i <= 30; i++) {
            const img = await loadImage(`data/back/back_${i}.png`);
            if (img) assets.backgrounds[i] = img;
        }

        // Load character sprites
        updateProgress('Loading character...');
        try {
            const charRes = await fetch('data/character/00002000.json');
            assets.character.data = await charRes.json();
        } catch(e) { console.log('No character JSON'); }

        // Load character walk sprites
        for (let i = 0; i < 4; i++) {
            assets.character.sprites[`walk1_${i}_body`] = await loadImage(`data/character/walk1_${i}_body.png`);
            assets.character.sprites[`walk1_${i}_arm`] = await loadImage(`data/character/walk1_${i}_arm.png`);
        }

        // Load character stand sprites
        for (let i = 0; i < 3; i++) {
            assets.character.sprites[`stand1_${i}_body`] = await loadImage(`data/character/stand1_${i}_body.png`);
            assets.character.sprites[`stand1_${i}_arm`] = await loadImage(`data/character/stand1_${i}_arm.png`);
        }

        // Load character jump sprite
        assets.character.sprites['jump_0_body'] = await loadImage('data/character/jump_0_body.png');
        assets.character.sprites['jump_0_arm'] = await loadImage('data/character/jump_0_arm.png');

        // Load character attack sprites (swingo1)
        for (let i = 0; i < 3; i++) {
            assets.character.sprites[`swingo1_${i}_body`] = await loadImage(`data/character/swingo1_${i}_body.png`);
            assets.character.sprites[`swingo1_${i}_arm`] = await loadImage(`data/character/swingo1_${i}_arm.png`);
        }

        // Load mobs
        updateProgress('Loading monsters...');
        for (const mobId of MOB_TYPES) {
            assets.mobs[mobId] = { sprites: {}, data: null };

            try {
                const mobRes = await fetch(`data/mob/${mobId}.json`);
                assets.mobs[mobId].data = await mobRes.json();
            } catch(e) {}

            // Load mob sprites
            for (let i = 0; i < 8; i++) {
                assets.mobs[mobId].sprites[`stand_${i}`] = await loadImage(`data/mob/${mobId}/stand_${i}.png`);
                assets.mobs[mobId].sprites[`move_${i}`] = await loadImage(`data/mob/${mobId}/move_${i}.png`);
                assets.mobs[mobId].sprites[`hit1_${i}`] = await loadImage(`data/mob/${mobId}/hit1_${i}.png`);
                assets.mobs[mobId].sprites[`die1_${i}`] = await loadImage(`data/mob/${mobId}/die1_${i}.png`);
            }
        }

        // Load effects
        updateProgress('Loading effects...');
        for (let i = 0; i < 21; i++) {
            assets.effects[`levelup_${i}`] = await loadImage(`data/effect/basiceff/levelup_${i}.png`);
        }

        // Load skill effects
        updateProgress('Loading skills...');
        for (let i = 0; i < 7; i++) {
            assets.skills[`skill_effect_${i}`] = await loadImage(`data/skill/12100/skill_121001000_effect_${i}.png`);
            assets.skills[`skill_hit_${i}`] = await loadImage(`data/skill/12100/skill_121001000_hit_0_${i}.png`);
        }

        // Load map data
        updateProgress('Loading map...');
        try {
            const mapRes = await fetch('data/map/993257000.json');
            mapData = await mapRes.json();
            parseFootholds();
        } catch(e) {
            console.log('No map data, using default');
            // Default footholds
            footholds = [
                { x1: -400, y1: 10, x2: 400, y2: 10 },
                { x1: -200, y1: -100, x2: 200, y2: -100 },
                { x1: -300, y1: -200, x2: 300, y2: -200 }
            ];
        }

        updateProgress('Ready!');
        loadingProgress.style.width = '100%';

        setTimeout(() => {
            document.getElementById('loading-screen').style.display = 'none';
            document.getElementById('start-screen').style.display = 'flex';
        }, 500);
    }

    // Parse footholds from map data
    function parseFootholds() {
        footholds = [];
        if (mapData?.foothold) {
            for (const layerId in mapData.foothold) {
                const layer = mapData.foothold[layerId];
                for (const groupId in layer) {
                    const group = layer[groupId];
                    for (const fhId in group) {
                        const fh = group[fhId];
                        if (fh.x1 !== undefined) {
                            footholds.push({
                                x1: fh.x1, y1: fh.y1,
                                x2: fh.x2, y2: fh.y2
                            });
                        }
                    }
                }
            }
        }

        // If no footholds, create default
        if (footholds.length === 0) {
            footholds = [
                { x1: -400, y1: 10, x2: 400, y2: 10 },
                { x1: -200, y1: -100, x2: 200, y2: -100 }
            ];
        }
    }

    // Start game
    function startGame() {
        document.getElementById('start-screen').style.display = 'none';
        gameRunning = true;

        // Reset player
        player.x = 0;
        player.y = -100;
        player.vx = 0;
        player.vy = 0;
        player.level = 1;
        player.hp = 100;
        player.maxHp = 100;
        player.mp = 50;
        player.maxMp = 50;
        player.exp = 0;
        player.expToLevel = 100;
        player.attack = 30;
        player.score = 0;
        player.kills = 0;

        mobs = [];
        damagePopups = [];
        effects = [];
        mobSpawnTimer = 0;

        lastTime = performance.now();
        requestAnimationFrame(gameLoop);
    }

    // Game loop
    function gameLoop(timestamp) {
        if (!gameRunning) return;

        const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
        lastTime = timestamp;

        update(dt);
        render();

        requestAnimationFrame(gameLoop);
    }

    // Update
    function update(dt) {
        updatePlayer(dt);
        updateMobs(dt);
        updateEffects(dt);
        updateCamera();
        spawnMobs(dt);
        updateUI();
    }

    // Update player
    function updatePlayer(dt) {
        // Movement
        const speed = 4;
        if (keys['ArrowLeft']) {
            player.vx = -speed;
            player.facing = -1;
            if (player.onGround && !player.attacking) player.state = 'walk1';
        } else if (keys['ArrowRight']) {
            player.vx = speed;
            player.facing = 1;
            if (player.onGround && !player.attacking) player.state = 'walk1';
        } else {
            player.vx = 0;
            if (player.onGround && !player.attacking) player.state = 'stand1';
        }

        // Jump
        if ((keys['ArrowUp'] || keys['c'] || keys['C']) && player.onGround) {
            player.vy = -12;
            player.onGround = false;
            player.state = 'jump';
        }

        // Attack
        if ((keys['z'] || keys['Z']) && !player.attacking && player.attackTimer <= 0) {
            player.attacking = true;
            player.attackTimer = 0.4;
            player.state = 'swingo1';
            player.frame = 0;
            performAttack();
        }

        // Skill
        if ((keys['x'] || keys['X']) && player.skillCooldown <= 0 && player.mp >= 20) {
            player.mp -= 20;
            player.skillCooldown = 2;
            performSkill();
        }

        // Gravity
        player.vy += 0.6;

        // Apply velocity
        player.x += player.vx;
        player.y += player.vy;

        // Foothold collision
        player.onGround = false;
        for (const fh of footholds) {
            if (player.vy >= 0 &&
                player.x >= fh.x1 - 20 && player.x <= fh.x2 + 20 &&
                player.y + player.height >= fh.y1 && player.y + player.height <= fh.y1 + 20) {
                player.y = fh.y1 - player.height;
                player.vy = 0;
                player.onGround = true;
                if (!player.attacking && player.vx === 0) player.state = 'stand1';
                break;
            }
        }

        // Fall limit
        if (player.y > 200) {
            player.y = -200;
            player.vy = 0;
        }

        // Animation
        player.frameTimer += dt;
        const frameDelay = player.state === 'walk1' ? 0.15 : (player.state === 'swingo1' ? 0.1 : 0.3);
        if (player.frameTimer >= frameDelay) {
            player.frameTimer = 0;
            const maxFrames = player.state === 'walk1' ? 4 : (player.state === 'stand1' ? 3 : (player.state === 'swingo1' ? 3 : 1));
            player.frame = (player.frame + 1) % maxFrames;
        }

        // Attack timer
        if (player.attackTimer > 0) {
            player.attackTimer -= dt;
            if (player.attackTimer <= 0) {
                player.attacking = false;
            }
        }

        // Cooldowns
        if (player.skillCooldown > 0) player.skillCooldown -= dt;
        if (player.invincible > 0) player.invincible -= dt;
    }

    // Perform attack
    function performAttack() {
        const attackRange = {
            x: player.facing > 0 ? player.x : player.x - 80,
            y: player.y,
            width: 120,
            height: 80
        };

        for (const mob of mobs) {
            if (mob.state !== 'dead' && checkCollision(attackRange, mob)) {
                const damage = player.attack + Math.floor(Math.random() * 20) + player.level * 3;
                const crit = Math.random() < 0.15;
                mob.takeDamage(crit ? damage * 2 : damage, crit);
            }
        }
    }

    // Perform skill
    function performSkill() {
        effects.push({
            type: 'skill',
            x: player.x,
            y: player.y,
            frame: 0,
            timer: 0
        });

        // AoE damage
        for (const mob of mobs) {
            if (mob.state !== 'dead') {
                const dist = Math.abs(mob.x - player.x);
                if (dist < 250) {
                    const damage = player.attack * 3 + player.level * 10;
                    mob.takeDamage(damage, true);
                }
            }
        }
    }

    // Spawn mobs
    function spawnMobs(dt) {
        mobSpawnTimer -= dt;
        if (mobSpawnTimer <= 0 && mobs.length < 5 + player.level) {
            mobSpawnTimer = Math.max(1, 3 - player.level * 0.2);

            const type = MOB_TYPES[Math.floor(Math.random() * MOB_TYPES.length)];
            const side = Math.random() < 0.5 ? -1 : 1;
            const x = player.x + side * (400 + Math.random() * 200);

            mobs.push(new Mob(type, x, -200));
        }
    }

    // Mob class
    class Mob {
        constructor(type, x, y) {
            this.type = type;
            this.x = x;
            this.y = y;
            this.vx = 0;
            this.vy = 0;
            this.width = 60;
            this.height = 60;
            this.facing = Math.random() < 0.5 ? -1 : 1;
            this.state = 'stand';
            this.frame = 0;
            this.frameTimer = 0;
            this.moveTimer = 0;

            const mobInfo = assets.mobs[type]?.data?.info;
            this.level = mobInfo?.level || (10 + player.level);
            this.maxHp = Math.min(mobInfo?.maxHP || 200, 300 + player.level * 50);
            this.hp = this.maxHp;
            this.attack = Math.min(mobInfo?.PADamage || 15, 10 + player.level * 2);
            this.exp = mobInfo?.exp || (20 + player.level * 5);
            this.speed = Math.abs(mobInfo?.speed || 50) / 30;
        }

        update(dt) {
            if (this.state === 'dead') {
                this.frameTimer += dt;
                if (this.frameTimer > 0.1) {
                    this.frameTimer = 0;
                    this.frame++;
                }
                return this.frame >= 6;
            }

            if (this.state === 'hit') {
                this.frameTimer += dt;
                if (this.frameTimer > 0.3) {
                    this.state = 'stand';
                    this.frameTimer = 0;
                }
                return false;
            }

            // AI
            this.moveTimer -= dt;
            if (this.moveTimer <= 0) {
                this.moveTimer = 1 + Math.random() * 2;
                const dx = player.x - this.x;
                if (Math.abs(dx) < 300) {
                    this.vx = dx > 0 ? this.speed : -this.speed;
                    this.facing = dx > 0 ? 1 : -1;
                    this.state = 'move';
                } else {
                    this.vx = (Math.random() - 0.5) * this.speed;
                    this.state = this.vx !== 0 ? 'move' : 'stand';
                }
            }

            // Gravity
            this.vy += 0.5;
            this.x += this.vx;
            this.y += this.vy;

            // Foothold
            for (const fh of footholds) {
                if (this.vy >= 0 &&
                    this.x >= fh.x1 - 20 && this.x <= fh.x2 + 20 &&
                    this.y + this.height >= fh.y1 && this.y + this.height <= fh.y1 + 20) {
                    this.y = fh.y1 - this.height;
                    this.vy = 0;
                    break;
                }
            }

            // Animation
            this.frameTimer += dt;
            if (this.frameTimer > 0.15) {
                this.frameTimer = 0;
                this.frame = (this.frame + 1) % 4;
            }

            // Attack player
            if (player.invincible <= 0 && checkCollision(this, player)) {
                player.hp -= this.attack;
                player.invincible = 1.5;
                showDamage(player.x, player.y - 20, this.attack, 'player');

                if (player.hp <= 0) {
                    gameOver();
                }
            }

            return false;
        }

        takeDamage(amount, crit) {
            this.hp -= amount;
            this.state = 'hit';
            this.frameTimer = 0;
            this.frame = 0;
            showDamage(this.x, this.y - 20, amount, crit ? 'crit' : 'mob');

            if (this.hp <= 0) {
                this.die();
            }
        }

        die() {
            this.state = 'dead';
            this.frame = 0;
            this.frameTimer = 0;
            player.kills++;
            player.score += this.level * 10;
            gainExp(this.exp);
        }

        draw() {
            const sprites = assets.mobs[this.type]?.sprites;
            const stateName = this.state === 'dead' ? 'die1' : (this.state === 'hit' ? 'hit1' : (this.state === 'move' ? 'move' : 'stand'));
            const sprite = sprites?.[`${stateName}_${this.frame % 4}`] || sprites?.['stand_0'];

            if (sprite) {
                ctx.save();
                ctx.translate(this.x - camera.x + GAME_WIDTH/2, this.y - camera.y + GAME_HEIGHT/2);
                ctx.scale(-this.facing, 1);
                ctx.drawImage(sprite, -sprite.width/2, -sprite.height + 10, sprite.width, sprite.height);
                ctx.restore();
            }

            // HP bar
            if (this.state !== 'dead') {
                const screenX = this.x - camera.x + GAME_WIDTH/2;
                const screenY = this.y - camera.y + GAME_HEIGHT/2 - this.height - 10;
                ctx.fillStyle = '#333';
                ctx.fillRect(screenX - 25, screenY, 50, 6);
                ctx.fillStyle = this.hp / this.maxHp > 0.3 ? '#00ff00' : '#ff0000';
                ctx.fillRect(screenX - 25, screenY, 50 * (this.hp / this.maxHp), 6);
            }
        }
    }

    // Show damage number
    function showDamage(x, y, amount, type) {
        const popup = document.createElement('div');
        popup.className = `damage-popup ${type}`;
        popup.textContent = amount;
        popup.style.left = (x - camera.x + GAME_WIDTH/2) + 'px';
        popup.style.top = (y - camera.y + GAME_HEIGHT/2) + 'px';
        document.getElementById('ui-layer').appendChild(popup);
        setTimeout(() => popup.remove(), 1000);
    }

    // Gain experience
    function gainExp(amount) {
        player.exp += amount;
        showDamage(player.x, player.y - 40, '+' + amount + ' EXP', 'exp');

        while (player.exp >= player.expToLevel) {
            levelUp();
        }
    }

    // Level up
    function levelUp() {
        player.exp -= player.expToLevel;
        player.level++;
        player.expToLevel = Math.floor(player.expToLevel * 1.5);
        player.maxHp += 20;
        player.maxMp += 10;
        player.hp = player.maxHp;
        player.mp = player.maxMp;
        player.attack += 5;

        effects.push({
            type: 'levelup',
            x: player.x,
            y: player.y,
            frame: 0,
            timer: 0
        });
    }

    // Update effects
    function updateEffects(dt) {
        effects = effects.filter(e => {
            e.timer += dt;
            if (e.timer > 0.08) {
                e.timer = 0;
                e.frame++;
            }
            return e.frame < 21;
        });
    }

    // Update camera
    function updateCamera() {
        camera.x = player.x;
        camera.y = player.y - 100;
    }

    // Update UI
    function updateUI() {
        document.getElementById('level').textContent = player.level;
        document.getElementById('hp-cur').textContent = Math.max(0, Math.floor(player.hp));
        document.getElementById('hp-max').textContent = player.maxHp;
        document.getElementById('mp-cur').textContent = Math.max(0, Math.floor(player.mp));
        document.getElementById('mp-max').textContent = player.maxMp;
        document.getElementById('exp-cur').textContent = player.exp;
        document.getElementById('exp-max').textContent = player.expToLevel;
        document.getElementById('score').textContent = player.score;
        document.getElementById('kills').textContent = player.kills;

        document.getElementById('hp-bar').style.width = (player.hp / player.maxHp * 100) + '%';
        document.getElementById('mp-bar').style.width = (player.mp / player.maxMp * 100) + '%';
        document.getElementById('exp-bar').style.width = (player.exp / player.expToLevel * 100) + '%';
    }

    // Update mobs
    function updateMobs(dt) {
        mobs = mobs.filter(mob => !mob.update(dt));
    }

    // Check collision
    function checkCollision(a, b) {
        return a.x - a.width/2 < b.x + b.width/2 &&
               a.x + a.width/2 > b.x - b.width/2 &&
               a.y < b.y + b.height &&
               a.y + (a.height || 0) > b.y;
    }

    // Game over
    function gameOver() {
        gameRunning = false;
        alert(`Game Over!\n\nLevel: ${player.level}\nScore: ${player.score}\nKills: ${player.kills}`);
        document.getElementById('start-screen').style.display = 'flex';
    }

    // Render
    function render() {
        ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

        // Draw background
        drawBackground();

        // Draw footholds
        drawFootholds();

        // Draw mobs
        mobs.forEach(mob => mob.draw());

        // Draw player
        drawPlayer();

        // Draw effects
        drawEffects();
    }

    // Draw background
    function drawBackground() {
        // Sky gradient
        const grad = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
        grad.addColorStop(0, '#87CEEB');
        grad.addColorStop(1, '#E0F6FF');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

        // Draw background images if loaded
        if (assets.backgrounds[0]) {
            const bg = assets.backgrounds[0];
            for (let i = -1; i <= 2; i++) {
                const x = ((camera.x * 0.3) % bg.width) + i * bg.width;
                ctx.drawImage(bg, GAME_WIDTH/2 - x, GAME_HEIGHT - bg.height);
            }
        }
    }

    // Draw footholds
    function drawFootholds() {
        ctx.strokeStyle = '#5a3d2b';
        ctx.lineWidth = 8;
        ctx.lineCap = 'round';

        for (const fh of footholds) {
            const x1 = fh.x1 - camera.x + GAME_WIDTH/2;
            const y1 = fh.y1 - camera.y + GAME_HEIGHT/2;
            const x2 = fh.x2 - camera.x + GAME_WIDTH/2;
            const y2 = fh.y2 - camera.y + GAME_HEIGHT/2;

            // Draw platform
            ctx.strokeStyle = '#4a2d1b';
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();

            // Grass on top
            ctx.strokeStyle = '#228B22';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x1, y1 - 3);
            ctx.lineTo(x2, y2 - 3);
            ctx.stroke();
            ctx.lineWidth = 8;
        }
    }

    // Draw player
    function drawPlayer() {
        const screenX = player.x - camera.x + GAME_WIDTH/2;
        const screenY = player.y - camera.y + GAME_HEIGHT/2;

        ctx.save();
        ctx.translate(screenX, screenY);
        ctx.scale(player.facing, 1);

        // Flash when invincible
        if (player.invincible > 0 && Math.floor(player.invincible * 10) % 2 === 0) {
            ctx.globalAlpha = 0.5;
        }

        // Get sprite based on state
        const frame = player.frame;
        const body = assets.character.sprites[`${player.state}_${frame}_body`];
        const arm = assets.character.sprites[`${player.state}_${frame}_arm`];

        if (body) {
            // Parse origin from JSON if available
            let bodyOrigin = { x: 19, y: 32 };
            let armOrigin = { x: 6, y: 8 };

            if (assets.character.data?.[player.state]?.[frame]) {
                const frameData = assets.character.data[player.state][frame];
                if (frameData.body?.origin) {
                    const [ox, oy] = frameData.body.origin.split(',').map(n => parseInt(n.trim()));
                    bodyOrigin = { x: ox, y: oy };
                }
                if (frameData.arm?.origin) {
                    const [ox, oy] = frameData.arm.origin.split(',').map(n => parseInt(n.trim()));
                    armOrigin = { x: ox, y: oy };
                }
            }

            // Draw body
            ctx.drawImage(body, -bodyOrigin.x, -bodyOrigin.y);

            // Draw arm
            if (arm) {
                ctx.drawImage(arm, -armOrigin.x - 5, -armOrigin.y + 5);
            }
        } else {
            // Fallback: simple character
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(-15, -50, 30, 45);
            ctx.fillStyle = '#FFDAB9';
            ctx.beginPath();
            ctx.arc(0, -55, 12, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.restore();
    }

    // Draw effects
    function drawEffects() {
        for (const e of effects) {
            const screenX = e.x - camera.x + GAME_WIDTH/2;
            const screenY = e.y - camera.y + GAME_HEIGHT/2;

            if (e.type === 'levelup') {
                const sprite = assets.effects[`levelup_${e.frame}`];
                if (sprite) {
                    ctx.drawImage(sprite, screenX - sprite.width/2, screenY - sprite.height);
                }
            }

            if (e.type === 'skill') {
                const sprite = assets.skills[`skill_effect_${e.frame % 7}`];
                if (sprite) {
                    ctx.drawImage(sprite, screenX - sprite.width/2, screenY - sprite.height/2);
                }
            }
        }
    }

    // Input handlers
    document.addEventListener('keydown', e => {
        keys[e.key] = true;
        if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'c', 'C', 'z', 'Z', 'x', 'X'].includes(e.key)) {
            e.preventDefault();
        }
    });

    document.addEventListener('keyup', e => {
        keys[e.key] = false;
    });

    // Start loading
    loadAssets();
    </script>
</body>
</html>
